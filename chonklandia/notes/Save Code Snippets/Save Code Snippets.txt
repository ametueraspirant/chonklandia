// #TEST
var buffer = buffer_load("isometric_csv_b.json");
var json = buffer_read(buffer, buffer_text);
buffer_delete(buffer);
testgrid = json_parse(json);
show_debug_message(testgrid.layers[0]);

///mouse_3d(xfrom, yfrom, zfrom, xto, yto, zto, xup, yup, zup, angle, aspect)
var mm, mX, mY, mZ, width, height, tFOV;
dX = argument3-argument0;
dY = argument4-argument1;
dZ = argument5-argument2;
mm = sqrt(dXdX+dYdY+dZdZ);
dX /= mm;
dY /= mm;
dZ /= mm;
uX = argument6;
uY = argument7;
uZ = argument8;
mm = uXdX+uYdY+uZdZ;
uX -= mmdX;
uY -= mmdY;
uZ -= mmdZ
mm = sqrt(uXuX+uYuY+uZuZ);
uX /= mm;
uY /= mm;
uZ /= mm;
// v = u x d
vX = uYdZ-dYuZ;
vY = uZdX-dZuX;
vZ = uXdY-dXuY;
tFOV = tan(argument9*pi/360);
uX *= tFOV;
uY *= tFOV;
uZ *= tFOV;
vX = tFOVargument10;
vY = tFOVargument10;
vZ = tFOVargument10;
width = window_get_width();
height = window_get_height();
mX = dX+uX(1-2mouse_y/height)+vX(2mouse_x/width-1);
mY = dY+uY(1-2mouse_y/height)+vY(2mouse_x/width-1);
mZ = dZ+uZ(1-2mouse_y/height)+vZ(2mouse_x/width-1);
mm = sqrt(mXmX+mYmY+mZ*mZ);
mouse_3dx = mX/mm;
mouse_3dy = mY/mm;
mouse_3dz = mZ/mm;






/// @description convert_2d_to_3d(camera, x, y)
/// @param camera
/// @param x
/// @param y
/*
Transforms a 2D coordinate (in window space) to a 3D vector.
Returns an array of the following format:
[dx, dy, dz, ox, oy, oz]
where [dx, dy, dz] is the direction vector and [ox, oy, oz] is the origin of the ray.

Works for both orthographic and perspective projections.

Script created by TheSnidr
*/
var camera = argument0;
var _x = argument1;
var _y = argument2;

var V = camera_get_view_mat(camera);
var P = camera_get_proj_mat(camera);

var mx = 2 * (_x / window_get_width() - .5) / P[0];
var my = 2 * (_y / window_get_height() - .5) / P[5];
var camX = - (V[12] * V[0] + V[13] * V[1] + V[14] * V[2]);
var camY = - (V[12] * V[4] + V[13] * V[5] + V[14] * V[6]);
var camZ = - (V[12] * V[8] + V[13] * V[9] + V[14] * V[10]);

if (P[15] == 0)
{    //This is a perspective projection
    return [V[2]  + mx * V[0] + my * V[1],
            V[6]  + mx * V[4] + my * V[5],
            V[10] + mx * V[8] + my * V[9],
            camX,
            camY,
            camZ];
}
else
{    //This is an ortho projection
    return [V[2],
            V[6],
            V[10],
            camX + mx * V[0] + my * V[1],
            camY + mx * V[4] + my * V[5],
            camZ + mx * V[8] + my * V[9]];
}







/// @description convert_3d_to_2d(x, y, z, viewMat, projMat)
/// @param x
/// @param y
/// @param z
/// @param viewMat
/// @param projMat
/*
    Transforms a 3D coordinate to a 2D coordinate. Returns an array of the following format:
    [x, y]
    where x and y are between (0, 0) (top left) and (1, 1) (bottom right) of the screen
    Returns [-1, -1] if the 3D point is behind the camera

    Works for both orthographic and perspective projections.
 
    Script created by TheSnidr
    www.thesnidr.com
*/
var _x = argument0;
var _y = argument1;
var _z = argument2;
var V = argument3;
var P = argument4;

var w = V[2] * _x + V[6] * _y + V[10] * _z + V[14];
if w <= 0
{
    return [-1, -1];
}
var cx, cy;
if (P[15] == 0)
{    //This is a perspective projection
    cx = P[8] + P[0] * (V[0] * _x + V[4] * _y + V[8] * _z + V[12]) / w;
    cy = P[9] + P[5] * (V[1] * _x + V[5] * _y + V[9] * _z + V[13]) / w;
}
else
{    //This is an ortho projection
    cx = P[12] + P[0] * (V[0] * _x + V[4] * _y + V[8]  * _z + V[12]);
    cy = P[13] + P[5] * (V[1] * _x + V[5] * _y + V[9]  * _z + V[13]);
}
return [.5 + .5 * cx, .5 - .5 * cy];